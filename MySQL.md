# MySQL
## 为什么使用数据库
- 数据存储在内存中
  - 优点 存取速度快
  - 缺点 无法持久化
- 数据保存在文件中
  - 优点 可持久化
  - 缺点 速度慢于内存 查询不方便
- 数据库
  - 数据持久化
  - 使用SQL语句方便存取
  - 方便管理数据
## 什么是SQL
结构化查询语言Structured Query Language
## 什么是MySQL
关系型数据库
## 数据库三范式
1. 每列无法再拆分
2. 非主键列依赖主键 而非主键的一部分
3. 非主键列只依赖于主键
## binlog的录入格式
- statement
  - 每一条修改记录的sql都会记录 修改的时候会保存相关的上下文 函数之类的语句不会被记录
- row
  - 保存每一行修改的数据 但是数据量很大
- mixed
  - 普通操作使用statement 无法使用statement的场景下使用row
## 数据类型
- 整型
  - 以下数据类型都可以加上unsigned 表示无符号整型
  - tinyInt 8位
  - smallInt 16位
  - mediumInt 24位
  - int 32位
  - bigInt 64位
- 小数类型
  - float 单精度浮点数
  - double 双精度浮点数
  - decimal(m, d) 精确存储小数 但是操作效率低（相当于把小数用字符串存储）
- 字符串类型
  - char(m) 存储0～255长度的字符串
  - varchar(m) 存储0～65535长度的字符串 可变长 比char节省空间
  - tinyblob
  - blob
  - mediumblob
  - longblob
  - tinytext
  - text
  - mediumblob
  - longtext
  - varbinary(m)
  - binary(m)
- 枚举类型
- 时间
  - timestamp
  - datetime
## InnoDB和MyISAM
            InnoDB      MyISAM
    外键     支持        不支持
    事务     支持        不支持
    锁       行/表锁     表锁
            修改性能高   查询性能高
            count性能低  维护了count变量
    索引    B+Tree聚簇索引 B+Tree非聚簇索引
## InnoDB四大特性
- 插入缓存
- 二次写
- 自适应哈希索引
- 预读
## 索引
索引包含了所有数据行的指针 对于查询有优化
## 索引优缺点
- 优点
  - 加快查询速度
- 缺点
  - 占用空间
  - 在数据insert和delete时维护 降低效率
## 索引使用场景
- where后的条件是索引可以提高效率
- order by后字段如果有索引就可以通过磁盘中索引存储的顺序输出
- join中on涉及的字段有索引可以提高效率
- 索引覆盖 在所有查询的字段都存在索引 那么就不会去查找原始数据
## 索引类型
- 主键索引
  - 非空唯一 一个表只有一个主键索引
- 唯一索引
  - 可空唯一
- 普通索引
  - 可空非唯一
- 全文索引
## 索引的数据结构
- B+Tree
  - 数据存在叶子节点上
  - 非叶子节点只存储其子节点的索引的最大或最小值
- hash索引
  - 计算数据的hash值 类似于HashMap的数据结构存储
## 索引基本原理
如果没有索引 查询数据的时候需要遍历所有数据
## 索引设计原则
- 将常常会出现在where后的字段作为索引
- 数据较少的表不适合设计索引
- 使用短索引 较长的字符串应当指定一个前缀长度
- 索引不应该过多 不但占用磁盘 还会降低写的效率
## 创建索引的原则
- 最左匹配原则
  - 在多条件时 遇到范围查询会停止
  - where a = 1 and b = 2 and c < 3 and d = 4 有索引(a, b, c, d)d就无法使用索引 在这种情况下索引应该设计为 (a, b, d, c)
- 频繁作为查询条件的列作为索引
- 更新频繁的列不适合作为索引
- 区分度过低的列不适合作为索引（如性别只有男/女/未知 区分度太低）
- 尽量扩展索引 不要新建索引（如当前有a索引 那么使用(a, b)索引只需要修改原有的索引）
- 定义有外键的列一定要加索引
- 查询中很少涉及的列不要建立索引
- 较大的列不要建立索引
## 创建索引的注意点
- 尽量在非空字段上创建索引 因为空值在比较统计信息时比较复杂
- 取离散值较大的数据放在联合索引的前面
- 索引字段越小越好
## 百万级别的表如何删除数据
- 删除索引
- 删除数据
- 创建索引
## BTree和B+Tree的区别
- 关于数据存储
  - BTree存储在各个节点上
  - B+Tree存储在叶子节点上
- B+Tree叶子节点中会包含其右边的叶子节点的指针
- 优缺点
  - BTree如果把频繁访问的数据放在离根比较进的位置时的效率比较高
  - B+Tree的数据都在根上 所以每次IO读取的键更多
  - 在范围查找上B+Tree只要找到头就可以顺序查找之后的节点 而BTree还是需要从根开始找
## 为什么更多使用B+Tree
- B+Tree适合随机查找和顺序查找 BTree只适合随机查找
- B+Tree空间利用率更高 可以减少IO次数
- B+Tree的查询时间是恒定的（因为每次都要查到根为止）
- BTree不适合顺序查找
- 在增删节点时由于有一个类似于链表的结构 B+Tree会更加方便
## 聚簇索引和非聚簇索引
- 聚簇索引
  - 数据和索引放在一起 找到索引也就找到了数据
- 非聚簇索引
  - 索引中只存放了数据的指针 找到索引后还需要去取得数据
  - 在辅助索引中存放的是主键 还需要到主键索引中查找数据
## 非聚簇索引是否必须回表查询
不是 如果查询的数据都命中索引 那么就不需要了
## 事务
事务是一个不可分割的数据库操作 其必定是将数据库从一个一致性变为另一个一致性
事务要么都执行 要么都不执行
## ACID
- A 原子性 事务是最小的执行单位 不可被拆分
- C 一致性 事务是将数据从一个一致性变为另一个一致性
- I 隔离性 并发访问数据库时 一个用户的事务不会被另一个事务干扰 各个并发事务之间是隔离的
- D 持久性 一个事务被提交之后改变是持久的 即使数据库发生故障也不会影响
## 脏读 幻读 不可重复读
- 脏读 读到别的事务处理数据的中间状态
- 幻读 一个事务在执行过程中同样的查询得到的数据量不一致
- 不可重复读 一个事务的两次查询的数据不同
## 隔离级别
- 读未提交
  - 没有隔离 会发生脏读 幻读 且不可重复读
- 读已提交
  - 不会发生脏读 但是不可重复读 会发生幻读
- 可重复读
  - 不会发生脏读 可重复读 会发生幻读
- 串行化
  - 都不会发生
隔离级别从上倒下依次变强 效率依次降低
## 锁
当数据库并发事务时可能会产生数据不一致 需要有一些机制来保证访问次序
## 隔离级别与锁
- 读未提交 读取数据不加共享锁
- 读已提交 读取数据加共享锁 在读取结束后释放
- 可重复读 读取数据加共享锁 直到事务结束释放
- 串行化 锁定整个范围的数据 直到事务结束释放
## 锁粒度
- MyISAM采用行锁
- InnoDB支持行锁和表锁 默认行锁
- 表锁
  - 对当前的表全锁 粒度最大 开销最小
  - 开销小 加锁快 不会出现死锁；粒度最大 发生冲突高 并发读最低
- 行锁
  - 只对当前操作的行加锁 粒度最小 开销最大
  - 开销大 加锁慢 会出现死锁；粒度最小 锁冲突概率低 并发度高
- 页锁
  - 介于行锁和表锁之间 一次锁定相邻的一组数据
  - 会发生死锁 别的介于表锁和行锁之间
## 锁类型
- 共享锁
  - 又叫读锁
  - 读取时加上 可以同时加上多个共享锁
- 排他锁
  - 又叫写锁
  - 写入时加上 排他锁和任何锁都是互斥的
## InooDB的行锁是如何实现的
- 通过索引来实现
  - update ... where 索引   使用行锁
  - update ... where 非索引 使用表锁
## InnoDB锁算法
- Record lock
  - 单个行记录上锁
- Gap lock
  - 间隙锁 锁定一个范围 不包括记录本身
- Next-key lock
  - 锁定一个范围 包括锁本身
## 死锁
- 和线程死锁的条件相同
- 如何解决
  - 如果会并发操作多个表 以相同的顺序访问
  - 保证一次锁定所有的资源
  - 经常发生死锁的情况可以升级为表锁
  - 可以通过分布式锁和乐观锁替代
## 乐观锁悲观锁
- 悲观锁
  - 在查询完数据后把事务锁起来 直到提交事务
  - 通过锁机制实现
- 乐观锁
  - 在修改数据的适合把事务锁起来 在提交时检查一致性
  - 通过version或CAS实现
- 适合场景
  - 频繁读适合乐观锁
  - 频繁写适合悲观锁
## 视图
为了提高复杂sql的复用性和安全性 本质是一种虚拟表
## 视图的特点
- 数据可以来自不同的表
- 是由基本表产生的
- 视图的建立和删除不影响基础表
- 对视图的修改会影响到基本表
- 当视图来自多个基本表时不影响修改
## 视图的使用场景
- 查询简单化
- 数据安全性
- 逻辑数据独立性
## 视图的缺点
- 性能 如果视图是一个复杂的查询 那么对视图的简单查询也会很消耗性能
- 修改限制
## 游标



## 日志
- MySQL中的日志
  - redo log
    - 用于事务提交 但是脏页还没有持久化时用于在数据库重启时恢复
    - 物理格式的日志 按照顺序在事务执行的过程中就写入了
    - 在事务持久化之后就会被释放（会被别的redo log覆盖）
  - undo log
  - bin log
  - 以下为与事务回滚无关的日志
    - error log
    - slow query log
    - general log
    - relay log
- 日志的作用
  - 用于保证事务失败时的回滚和事务成功后脏页未持久化的恢复
- undo log
  - 将还没有COMMIT的事务回滚到事务开始的状态
  - 在系统奔溃时 可能还有没有COMMIT的事务 在系统恢复时 需要借助undo log恢复
  - 要求
    - 必须要记录(T, x, v) T为事务 x为修改的数据 v为修改前的数据
    - 必须要在事务的修改都持久化之后才能写COMMIT T日志 这样能保证在宕机恢复时所有已经持久化的数据不需要回滚
  - 记录顺序
    1. START T
    2. 记录事务以及修改数据的旧值
    3. 将事务的修改更新
    4. 记录COMMIT T
  - 回滚过程
    1. 扫描日志 找到所有已经START T但是尚未COMMIT T的日志
    2. 针对这些事务 根据undo log回滚
  - 日志的优化 checkpoint
    - 用于加快回滚的速度
      1. 记录checkpoint_start(T1, T2, ...) 这些事务是当前checkpoint记录时START但是尚未COMMIT的事务
      2. 等待这些事务全部COMMIT
      3. 记录checkpoint_end
    - 回滚过程
      - 从后往前扫描日志
        - 如果先遇到checkpoint_start 将其之后所有未提交的事务都回滚
        - 如果先遇到checkpoint_end 将前一个checkpoint_start之后的所有未提交的事务回滚（因为在前一个checkpoint_start后会有很多START和COMMIT）
      - 这样的好处是不用扫描整个undo log
    - 使用undo log会要求所有COMMIT之前数据都是持久化的 这样很浪费性能
- redo log
  - 回放日志的适合将已经COMMIT的日志重做一遍 没有COMMIT的日志abort处理
  - 写COMMIT T日志之前 事务的修改不能进行持久化 否则恢复时 对于未COMMIT的操作 可能有数据已经修改 但重放redo log不会对该事务做任何处理 从而不能保证事务的原子性
  - 记录过程
    1. START T
    2. (T, x, v)
    3. COMMIT T
    4. 将事务修改持久化
  - 回滚过程
    1. 找到所有已经COMMIT的事务
    2. 根据redo log重做
  - 同样通过checkpoint优化
    1. 记录checkpoint_start(T1, T2, ...)
    2. 将所有已提交的事务持久化
    3. 记录checkpoint_end
  - 回滚过程
    - 从后向前扫描
      - 如果先遇到start 把T1～Tn和在其之后所有已经commit的日志重做
      - 如果先遇到end 把T1～Tn以及前一个start之后的commit重做