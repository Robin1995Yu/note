# Java 并发 && 多线程

## synchronized 的实现原理以及锁优化？
## ThreadLocal原理，使用注意点，应用场景有哪些？
    实际上是将数据存放在线程对象中
    线程对象中有一个threadLocals（key为TheadLocal value为值）
    这种设计方式可以将数据和线程绑定
    
## synchronized和ReentrantLock的区别？
## 说说CountDownLatch与CyclicBarrier 区别
## Fork/Join框架的理解
## 为什么我们调用start()方法时会执行run()方法，为什么我们不能直接调用run()方法？
## Java中的volatile关键是什么作用？怎样使用它？在Java中它跟synchronized方法有什么不同？volatile 的实现原理
## CAS？CAS 有什么缺陷，如何解决？
    比较与替换 
    在计算前保存数据副本 
    在赋值前将副本与当前值对比 如果相同则赋值 反之为失败
    ABA问题 副本和当前值对比的时候副本是从别的状态变化回来点
    解决 加上version 在每次修改都对version自增
## 如何检测死锁？怎么预防死锁？死锁四个必要条件
- 检测
    - jstack
    - jconsole
- 预防
    - 按照相同的顺序获得锁
    - 银行家算法
    - 超时放弃
- 死锁的条件
    - 互斥 一个资源只能一个线程使用
    - 占有且等待 在占有一个资源后得到下一个资源前不会释放
        - 解决 超时自动释放
    - 不可强行占有 资源被一个线程占有后就无法被剥夺
        - 给予操作系统权限剥夺某些线程的资源
    - 循环等待 若干线程头尾相接的等待资源的关系
        - 按照规定的顺序分配资源
## 如果线程过多,会怎样?
- 过多线程挂起占用内存
- 竞争时造成CPU的压力
- 超出jvm内存的话会oom
## 说说 Semaphore原理？
## AQS组件，实现原理
## 假设有T1、T2、T3三个线程，你怎样保证T2在T1执行完后执行，T3在T2执行完后执行？
    join
## LockSupport作用是？
## Condition接口及其实现原理
## 为什么要用线程池？Java的线程池内部机制，参数作用，几种工作阻塞队列，线程池类型以及使用场景
- 原因
    - 线程的创建和销毁很消耗时间
    - 池化管理线程
- 内部机制
    - 阻塞队列接收任务
    - 线程创建机制
        - 当前线程数小于corePoolSize 创建新的线程执行任务
        - 当前线程数大于等于corePoolSize 且阻塞队列未满 将任务加入阻塞队列
        - 当前线程大于等于corePoolSize小于maxmumPoolSize切阻塞队列满 创建新的线程
        - 当前线程大于等于corePoolSize且阻塞队列满 拒绝任务
    - 任务分配
        - 线程池是否停止
        - 现阶段的线程是否过多
        - 该线程是否在回收状态
    - 任务拒绝
        - ThreadPoolExecutor中有默认的拒绝机制
        - AbortPolicy 拒绝抛出错误
        - DiscardPolicy 拒绝不抛出错误
        - DiscardOldestPolicy 丢弃队列最前端的任务
        - CallerRunsPolicy 由任务发送的线程完成
## 如何保证多线程下 i++ 结果正确？
- 同步
- AtomicInteger
## 10 个线程和2个线程的同步代码，哪个更容易写？
## 什么是多线程环境下的伪共享（false sharing）？
    缓冲行频繁本地写 频繁ROC将缓存行变为I状态导致的效率问题
## 线程池如何调优，最大数目如何确认？
## Java 内存模型？
- Java Memory Model JMM
- Java虚拟机规范定义 屏蔽Java在不同硬件和操作系统中对内存的访问差异
## 说一下 Runnable和 Callable有什么区别？
- Runnable
    - 只有一个public void run()方法 没有返回值 只要一个Thread去调用它就可以了
- Callable
    - 一个泛型接口
    - 只有一个public T call()方法 返回T类型
- Future
- FutureTask
## 用Java编程一个会导致死锁的程序，你将怎么解决？
## 线程的生命周期，线程的几种状态。
- New 新建
    - 创建线程后 处于新建状态 只有JVM分配的内存
- Runnable 就绪
    - 调用start方法后 JVM会创建方法调用栈和程序计数器 等待调度运行
- Running 运行
    - 就绪线程去的CPU开始执行run
- Blocked 阻塞
    - 线程失去占用的资源
- Dead 死亡
## ReentrantLock实现原理
- 通过AQS实现
- 可重入锁 可以为公平或者非公平
    - 是否是公平锁通过构造函数
    - 默认非公平
- lock加锁
    - 通过tryAcquire(arg)尝试获取锁
        - 没有占用
            - 公平锁   判断AQS队列中是否有别的线程 有加入队尾 没有获取锁
            - 非公平锁 直接尝试获取锁 如果不成功再入队列
            - 获取锁后 通过CAS将状态写为已占用
        - 被占用
            - 将当前线程写入AQS的队尾
                - 如果队尾不为null
                    - 通过CAS将线程写入队尾
                - 通过CAS与自旋写入队尾
- unlock释放
    - 判断是否为当前占用锁的线程
        - 否 抛出IllegalMonitorStateException
        - 是
            - 将状态减少（只有状态变为0时才认为是释放了）
            - 如果状态为释放
                - 将当前的占有线程设为null
                - 唤醒队首线程
- 效率
    - 公平锁需要判断队列是否为空
    - 非公平锁不需要判断
    - 非公平锁效率高于公平锁
## java并发包concurrent及常用的类
- Callable
- 
## wait(),notify()和suspend(),resume()之间的区别
- wait
    - 阻塞 不能自动唤醒
- notify
    - 唤醒任意一条wait的线程 但是不确定是哪一条 所以大部分情况使用的是notifyAll
- suspend
    - 也是阻塞 但是不会释放锁
- resume
    - 唤醒suspend的线程
- suspend和resume已过时 因为有死锁倾向
## FutureTask是什么？
## 一个线程如果出现了运行时异常会怎么样
- 如果try catch了 可以继续执行
- 如果没有 线程停止执行
## 生产者消费者模型的作用是什么
    生产者和消费者解藕 他们只依赖于中间的队列 一方的修改不会影响到另一方
## ReadWriteLock是什么
- 维护了一对锁 一个用于只读 一个用于写入
- 只要没有writer 那么可以由多个reader同时保持
    - 适用于读比较多而写比较少的情况
    - 如果读的时间很短 那么锁的开销甚至会大于逻辑代码
- 策略
    - 一般是写锁优于读锁 因为在使用读写锁的场景下 读的时间比较短而且不会是否频繁
    - 如果有写的请求之后的读请求 是否授予锁 如果是 那么写可能会无限期的延迟
    - 是否可重入
        - 写锁是否可以同时保持读锁
        - 写锁是否可以重入写锁
    - 锁降级
## Java中用到的线程调度算法是什么？
## 线程池中的阻塞队列如果满了怎么办？
1. 如果线程数小于最大线程数 创建新的线程执行队头任务
2. 如果线程数大于等于最大线程数 根据拒绝策略拒绝
## 线程池中 submit()和 execute()方法有什么区别？

类型 | submit | execute
---|---|---
提交方式 | 将任务包装成FutureTask通过execute提交 | 直接将任务提交
错误处理 | 在FutureTask.get后会抛出错误 | 在遇到错误后直接抛出
线程复用 | 在遇到RuntimeException可以复用 | 在遇到RuntimeException不可复用
## 介绍一下 AtomicInteger 类的原理？
- volatile
    - 线程可见性（核心的缓存 这个通过同步也是可以实现的）
    - 禁止指令重排
- CAS
    - 比较和替换 一种乐观锁
## 多线程锁的升级原理是什么？
- 对象头
    - 对象实例在内存中的存储的一部分（对象头 实例变量 填充子节）
    - MarkWord
        - 对象运行时数据
        - 偏向锁   存放偏向线程的ID
        - 轻量级锁 指向栈中的锁记录的指针
        - 重量级锁 指向重量级锁的指针
    - Klass Point
        - 对象的类元数据的指针
- 锁的状态
    - 无锁
    - 偏向锁
        - 加锁和释放不需要额外的消耗
        - 如果线程间有竞争 会有锁撤销的消耗
        - 适用于只有一个线程访问同步代码块的
    - 轻量级锁
        - 竞争不会阻塞 提高响应速度
        - 不会释放CPU 通过自旋的方式等待
        - 同步代码块执行的很快且追求响应速度
    - 重量级锁
        - 直接放弃CPU资源 不浪费资源
        - 因为阻塞 响应慢
        - 吞吐量高 在同步代码块执行的比较耗时的情况下
- 锁的执行过程
    - 无锁
        - 不对对象加锁
        - 通过CAS或者乐观锁等方式实现同步
    - 偏向锁
        1. 通过CAS修改锁标志位为偏向锁
        2. 将线程ID写到MarkWord
        3. 退出同步锁的MarkWord还是当前线程的ID
        4. 再次进入的时候 如果MarkWord的线程ID还是自己的 那么就直接进入
        - 只有在遇到别的线程在竞争锁才会释放偏向锁
    - 轻量级锁
        - 当当前的锁为偏向锁且另一个线程来竞争的时候会升级为轻量级锁
        - 如果每次尝试获取偏向锁都没用阻塞 那么就不是锁竞争 只有当产生阻塞的时候才会升级为轻量级锁
        - 没用获取到锁的线程会不断的尝试获取锁（通过循环的方式 所以叫做自旋锁）
        - 自旋的时候叫做忙等（busy-waiting）
        - 虽然忙等的过程中占用资源且不做事 但是换取了线程切换的开销
    - 重量级锁
        - 当某个忙等的线程的自旋次数超出阈值（默认是10次 可以通过改虚拟机参数来修改）会升级为重量级锁（也是通过CAS来修改锁标志位）
        - 后续线程尝试获取锁时发现是重量级锁 就直接把自己挂起
## 指令重排序，内存栅栏等？
## Java 内存模型 happens-before原则
    由于读取内存的数据十分耗时 所以CPU允许指令重排 允许后面的指令先执行 最终保证运行结果是顺序运行的结果
- happends-before原则规则
    - 程序次序规则 一个线程内 按照书写顺序执行
        - 可能会发生指令重排 但是保证最终结果和顺序执行的结果相同
        - 只能在单线程中保证 多线程无法保证正确性
    - 锁定规则 一个释放操作必定发生在同一个加锁之后
    - volatile变量规则 对于一个变量的写操作必定发生在读之前
    - 传递规则 A先于B B先于C 那么A先于C
    - 线程启动规则 start方法先于线程的每一个动作
    - 线程中断规则 interrupt方法先于中断检测和中断事件
    - 线程终结规则 线程中所有操作都先于终止检测
    - 对象终结规则 初始化完成先于finalize方法
## 公平锁/非公平锁
- 公平锁
    - 将锁优先分配给等待时间最长的线程
    - 由于每次都需要去判断 所以效率比较低
- 非公平锁
    - 在锁释放后 所有线程都参与竞争
    - 不需要判断 效率高于公平锁
## 可重入锁
    同一线程的同步代码块中再次尝试获取这个锁不会被阻塞
## 独享锁、共享锁
- 独享锁
    - 一次只能被一条线程持有
- 共享锁
    - 一次可以被多条线程持有
## 偏向锁/轻量级锁/重量级锁
## 如何保证内存可见性
    volatile
## 非核心线程延迟死亡，如何实现？
- 当当前线程池为运行状态 线程数大于核心线程数获取任务事件大于keepAliveTime
## ConcurrentHashMap读操作为什么不需要加锁？
- 在1.8之前 是使用Segment分段锁来实现到
- 在1.8以及之后使用同步和CAS实现
    - put操作
        - 如果结点为空 通过CAS放入结点
        - 如果结点不为空 对链表头结点加锁 放入
## ThreadLocal 如何解决 Hash 冲突？
- 在Thread中存放键为ThreadLocal的Map
    - 同样是使用Hash表到方式 但是如果发现当前Hash的位置已经有别的元素了 那就着之后一定步长的位置 直到找到空
## ThreadLocal 的内存泄露是怎么回事？
## 为什么ThreadLocalMap 的 key是弱引用，设计理念是？
- 弱引用
    - 当一个对象只有弱引用 那么在下次GC到时候 不论内存有没有满 都会被回收
- 当ThreadLocal对象的生命周期已经结束了 Thread还是强引用 那么其ThreadLocalMap中的key是弱引用 会被回收
- 但是value是强引用 不会被回收
    - 在每次调用ThreadLocalMap到get set remove方法时会执行擦除key为null的Entry 最大程度上解决了泄漏
## 同步方法和同步代码块的区别是什么？

## 在Java中Lock接口比synchronized块的优势是什么？如果你需要实现一个高效的缓存，它允许多个用户读，但只允许一个用户写，以此来保持它的完整性，你会怎样去实现它？
- synchronized只能是非公平的互斥锁 使用方便 但是很死
- Lock接口使用不方便 需要手动加锁和释放 但是使用灵活
- 使用读写锁（ReadWriteLock）
## 用Java实现阻塞队列。
## 用Java写代码来解决生产者——消费者问题。
## 什么是竞争条件？你怎样发现和解决竞争？
    输出的数据依赖于线程获取锁的顺序等不可控的条件
## Java中你怎样唤醒一个阻塞的线程？
## 你在多线程环境中遇到的共同的问题是什么？你是怎么解决它的？
## Java 中能创建 volatile数组吗
    能 但是只能保证数据的指针是volatile的 不能保证数据
## volatile 能使得一个非原子操作变成原子操作吗
    不能
## 你是如何调用 wait（）方法的？使用 if 块还是循环？为什么？
    循环 直到条件满足再wait
## 我们能创建一个包含可变对象的不可变对象吗？
## 为什么Java中 wait 方法需要在 synchronized 的方法中调用？
## BlockingQueue，CountDownLatch及Semeaphore的使用场景
## Java中interrupted 和 isInterruptedd方法的区别？
## 怎么检测一个线程是否持有对象监视器
    Thread.holdLock(Object) true 持有 false 不持有
## 什么情况会导致线程阻塞
- sleep
- wait
- yield
- join
## 如何在两个线程间共享数据
- 单例模式
- 同一个Runnable对象
- 静态成员
- final局部变量
## 说说线程的生命周期和状态?
- 创建
- 运行
- 阻塞
- 运行
- 死亡
## 什么是上下文切换
    CPU控制权由一个正在运行的线程切换到另一个就绪并在等待的线程
## Java Monitor 的工作机理
- 通过c++实现
- 主要成员
    - owner
        - 当前持有监视器的线程对象
    - waitSet
        - wait的线程对象集合
    - entryList
        - 由于等待锁而阻塞的线程
    - recursions
        - 锁重入次数
    - count
        - 获取锁的次数
- 过程
    1. 进入同步代码首先进入entryList
    2. 获取锁成功 将owner改为当前线程 count自增
    3. wait owner赋值null count自减 线程进入waitSet
    4. 如果owner为当前线程 recursions自增（可重入）
## 按线程池内部机制，当提交新任务时，有哪些异常要考虑。
## 线程池都有哪几种工作队列？
## 说说几种常见的线程池及使用场景?
## 使用无界队列的线程池会导致内存飙升吗？
## 为什么阿里发布的 Java开发手册中强制线程池不允许使用 Executors 去创建？
## Future有缺陷嘛？
- get方法是阻塞的